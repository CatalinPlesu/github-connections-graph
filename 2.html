<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>GitHub Network Graph 2D</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        #graph {
            width: 100vw;
            height: 100vh;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/force-graph"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <div id="graph"></div>

    <script>
        fetch('graph-data.json')
            .then(res => res.json())
            .then(data => {
                const graphData = JSON.parse(JSON.stringify(data)); // deep clone
                
                // Set up highlighting system
                const highlightNodes = new Set();
                const highlightLinks = new Set();
                let hoverNode = null;
                
                // Cross-link node objects for neighbor tracking
                graphData.links.forEach(link => {
                    const a = graphData.nodes.find(node => node.id === (link.source.id || link.source));
                    const b = graphData.nodes.find(node => node.id === (link.target.id || link.target));
                    
                    if (a && b) {
                        !a.neighbors && (a.neighbors = []);
                        !b.neighbors && (b.neighbors = []);
                        a.neighbors.push(b);
                        b.neighbors.push(a);
                        
                        !a.links && (a.links = []);
                        !b.links && (b.links = []);
                        a.links.push(link);
                        b.links.push(link);
                    }
                });

                const Graph = ForceGraph()(document.getElementById('graph'))
                    .graphData(graphData)
                    .nodeId('id')
                    .nodeCanvasObject((node, ctx, globalScale) => {
                        const label = node.id;
                        const nodeSize = node.size || 5;

                        // Adjust font size based on zoom
                        const baseFontSize = 12;
                        const fontSize = Math.max(baseFontSize / globalScale, 4); // minimum 4px font size

                        let opacity = Math.min(globalScale, 1);
                        if (opacity < 0.5) {
                            opacity = 0;
                        }

                        // Draw highlight ring for highlighted nodes (before the main node)
                        if (highlightNodes.has(node)) {
                            ctx.beginPath();
                            ctx.arc(node.x, node.y, nodeSize * 1.4, 0, 2 * Math.PI, false);
                            ctx.fillStyle = node === hoverNode ? 'red' : 'orange';
                            ctx.fill();
                        }

                        // Draw main node circle
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, nodeSize, 0, 2 * Math.PI, false);
                        ctx.fillStyle = node.color || 'skyblue';
                        ctx.fill();

                        // Set fading text color and draw label
                        ctx.font = `${fontSize}px Sans-Serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
                        ctx.fillText(label, node.x, node.y + nodeSize + 2);
                    })
                    .nodeLabel(node => `${node.id}`)
                    .nodeVal(node => node.size || 1)
                    .nodeAutoColorBy('depth')
                    .linkSource('source')
                    .linkTarget('target')
                    .linkDirectionalArrowLength(4)
                    .linkDirectionalArrowRelPos(1)
                    .linkWidth(link => highlightLinks.has(link) ? 5 : 1)
                    .linkDirectionalParticles(4)
                    .linkDirectionalParticleWidth(link => highlightLinks.has(link) ? 4 : 0)
                    .onNodeHover(node => {
                        highlightNodes.clear();
                        highlightLinks.clear();
                        if (node) {
                            highlightNodes.add(node);
                            if (node.neighbors) {
                                node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
                            }
                            if (node.links) {
                                node.links.forEach(link => highlightLinks.add(link));
                            }
                        }
                        hoverNode = node || null;
                    })
                    .onLinkHover(link => {
                        highlightNodes.clear();
                        highlightLinks.clear();
                        if (link) {
                            highlightLinks.add(link);
                            const sourceNode = graphData.nodes.find(n => n.id === (link.source.id || link.source));
                            const targetNode = graphData.nodes.find(n => n.id === (link.target.id || link.target));
                            if (sourceNode) highlightNodes.add(sourceNode);
                            if (targetNode) highlightNodes.add(targetNode);
                        }
                    })
                    .autoPauseRedraw(false) // keep redrawing after engine has stopped
                    .onNodeClick(node => {
                        if (node.url) window.open(node.url, '_blank');
                    })
                    .onNodeRightClick((node, event) => {
                        event.preventDefault?.();

                        const toRemove = new Set();
                        const visited = new Set();

                        // Recursively collect all downstream nodes
                        function dfs(currentId) {
                            if (visited.has(currentId)) return;
                            visited.add(currentId);
                            toRemove.add(currentId);

                            graphData.links.forEach(link => {
                                if (link.source.id === currentId || link.source === currentId) {
                                    dfs(link.target.id || link.target);
                                }
                            });
                        }

                        dfs(node.id);

                        // Filter out nodes to be removed
                        graphData.nodes = graphData.nodes.filter(n => !toRemove.has(n.id));

                        // Filter out links related to removed nodes
                        graphData.links = graphData.links.filter(
                            l => !toRemove.has(l.source?.id || l.source) && !toRemove.has(l.target?.id || l.target)
                        );

                        // Re-assign new objects to force re-render
                        Graph.graphData({
                            nodes: [...graphData.nodes],
                            links: [...graphData.links]
                        });
                    });
            });
    </script>
</body>

</html>